package main

func main() {
	// 切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。
	// 因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制

	// type SliceHeader struct {
	// 	Data uintptr // 切片指向的底层字节数组
	// 	Len  int     // 切片指向的长度
	// 	Cap  int	 // 切片指向的内存空间的最大容量（对应元素的个数） 向后扩展
	// }
	// var (
	// 	a []int               // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片
	// 	b = []int{}           // 空切片, 和 nil 不相等, 一般用来表示一个空的集合
	// )

	// 内置的cap函数返回切片容量大小，容量必须大于或等于切片的长度
	// cap(a)

	// 在容量不足的情况下，append的操作会导致重新分配内存，可能导致巨大的内存分配和复制数据代价。即使容量足够，
	// 依然需要用append函数的返回值来更新切片本身，因为新切片的长度已经发生了变化

	// // 在i处添加一个元素
	// a = append(a, 0)
	// copy(a[i+1:], a[i:])
	// a[i] = x
	//
	// // 在i处添加多个元素
	// a = append(a, x...)
	// copy(a[i+len(x)+1:], a[i:])
	// copy(a[i:], x)

	// 删除切片元素 尾部删除最快

	// 切片为空 len==cap==0

}